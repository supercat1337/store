// version 1.0.0
var c=class{events={};on(e,t){typeof this.events[e]!="object"&&(this.events[e]=[]),this.events[e].push(t);let s=this;return function(){s.removeListener(e,t)}}removeListener(e,t){var s;typeof this.events[e]=="object"&&(s=this.events[e].indexOf(t),s>-1&&this.events[e].splice(s,1))}emit(e){if(typeof this.events[e]=="object"){var t,s,n,i=[].slice.call(arguments,1);for(s=this.events[e].slice(),n=s.length,t=0;t<n;t++)try{s[t].apply(this,i)}catch(r){console.error(e,i),console.error(r)}}}once(e,t){return this.on(e,function s(){this.removeListener(e,s),t.apply(this,arguments)})}};function d(o,e){if(o===e)return!0;if(o===null||e===null||o===void 0||e===void 0||typeof o!=typeof e)return!1;if(Array.isArray(o)||Array.isArray(e))return JSON.stringify(o)===JSON.stringify(e);let t=JSON.stringify(o,Object.keys(o).sort()),s=JSON.stringify(e,Object.keys(e).sort());return t===s}var a=class{value;old_value;item_name;eventType;property=null},v=/^([a-zA-Z_][a-zA-Z0-9_]*)$/;var g=class{#s=new Map;#e=new Map;#r=new Map;#o=null;#i={};#l=!1;#t=new c;constructor(e){e&&this.setItems(e)}log=console.log;#u(e){return v.test(e)}#g(e,t){let s=this.#s.get(e);this.#s.set(e,t);let n=!0;if(this.#i[e]?n=this.#i[e](s,t,e,null):n=d(s,t),!n){let i=new a;return i.eventType="set",i.item_name=e,i.value=t,i.old_value=s,i}return!1}#v(e,t){if(!this.#u(e))throw new Error(`${e} is wrong store's item_name`);this.#s.set(e,t)}#a(e,t,s){t=t.toString();let i=this.#r.get(e)[t],r=!0;if(this.#i[e]?(r=this.#i[e](i,s,e,t),this.log(r,i,s,e,t)):r=d(i,s),r)return!1;let l=new a;return l.eventType="set",l.item_name=e,l.property=t,l.value=s,l.old_value=i,l}#p(e,t){let s=this.#r.get(e),n=!0;s.length=t.length;for(let i=0;i<s.length;i++)this.#a(e,i.toString(),t[i])&&(n=!1);if(!n){let i=new a;return i.eventType="set",i.item_name=e,i.value=t,i}return!1}hasItem(e){return this.#s.has(e)||this.#e.has(e)||this.#r.has(e)}setItem(e,t){var s={[e]:t};this.setItems(s)}setItems(e){var t={},s=[],n=!1,i=new Set;for(let r in e){if(r=="store"||this.isComputedItem(r))continue;if(!this.hasItem(r)){if(this.#l){console.error(`Store is sealed. Can't create the item "${r}"`);continue}this.#v(r,void 0)}let l=e[r],u=this.isAtomItem(r),h=this.isCollection(r);if(u||h){let f=u?this.#g(r,l):this.#p(r,l);if(f==!1)continue;n=!0,t[r]=f,s.push(f),i.add(r)}}if(n){this.#e.forEach(r=>{if(!this.#I(r,i)||!this.hasSubscribers(r.item_name))return;let u=this.#h(r.item_name);u!==!1&&(t[r.item_name]=u,s.push(u))});for(let r=0;r<s.length;r++){let l=s[r];this.#t.emit(l.item_name,l,this)}this.#n(t,"set")}}isComputedItem(e){return this.#e.has(e)}isAtomItem(e){return this.#s.has(e)}isCollection(e){return this.#r.has(e)}#h(e){let t=this.#e.get(e),s=this,n=t.value;t.stale=!0;let i=t.getter(s);t.stale=!1;let r=!0;if(this.#i[e]?r=this.#i[e](n,i,e,null):r=d(n,i),r)return!1;t.value=i;let l=new a;return l.eventType="set",l.item_name=e,l.value=i,l.old_value=n,l}recalcComputed(e){if(!this.isComputedItem(e))return!1;let t=this.#h(e);return t&&this.hasSubscribers(e)&&this.#t.emit(e,t,this),t}#b(e,t,s){let n=this;if(s.length==0)throw new Error(`Computed item ${e} hasn't dependencies`);this.#e.set(e,{item_name:e,dependencies:s,getter:t,value:t(n),stale:!1})}#I(e,t){for(var s=e.dependencies,n=0;n<s.length;n++)if(t.has(s[n]))return e.stale=!0,!0;return!1}#f(e,t,s,n=!1){if(e=e.trim(),this.hasItem(e))return console.warn(`Item name ${e} name already exists`),!1;if(!n&&!this.#u(e))throw new Error(`${e} is wrong store's item_name`);let i=new Set;for(let r=0;r<s.length;r++){let l=s[r];if(!this.hasItem(l)){console.warn(`${e}: Unknown dependency ${l} is ignored`);continue}if(!this.isAtomItem(l)){console.warn(`${e}: The non-atom item ${l} is ignored`);continue}i.add(l)}return this.#b(e,t,Array.from(i)),!0}createComputedItem(e,t,s){return this.#l?(console.error(`Store is sealed. Can't create the item "${e}"`),!1):this.#f(e,t,s)}loadExpression(e){e=e.trim();let t=`{${e}}`;if(this.hasItem(t))return t;var s=new Set,n=e,i=n.matchAll(/\$[a-zA-Z_][a-zA-Z0-9_]*/g);for(let h of i){let f=h[0].slice(1);this.hasItem(f)&&s.add(f)}var r=Array.from(s),l=r.map(h=>`var $${h} = store.getItem("${h}");`).join(`
`),u=new Function("store",`
    ${l}
    return ${e};
`);return this.#f(t,u,r,!0),t}createCollection(e,t){if(e=e.trim(),this.hasItem(e)){console.warn(`Item name ${e} name already exists`);return}if(!this.#u(e))throw new Error(`${e} is wrong store's item_name`);var s=this,n=new Proxy(t,{deleteProperty:function(i,r){if(typeof r=="symbol")delete i[r];else if(typeof r=="string"){let l=new a;l.eventType="delete",l.item_name=e,l.value=i[r],l.property=r,delete i[r],s.#t.emit(l.item_name,l,s),s.#n({[e]:l},"delete")}return!0},set:function(i,r,l,u){if(typeof r=="symbol")i[r]=l;else if(typeof r=="string"){let h=s.#a(e,r,l);h&&(i[r]=l,s.#t.emit(h.item_name,h,s),s.#n({[e]:h},"set"))}return!0}});return s.#r.set(e,n),n}onChange(e){return this.#t.on("change",e)}onChangeAny(e,t){if(e.length==0)return;let s=this;return this.#t.on("change",function(i){let r=i.details,l=!1;for(let u in r)if(e.indexOf(u)>-1){l=!0;break}l&&t(i,s)})}deleteItem(e){if(this.#l)return console.error(`Store is sealed. Can't delete the item "${e}"`),!1;if(!this.hasItem(e))return!1;let t=this.getItem(e),s=new a;s.eventType="delete",s.item_name=e,s.value=t,this.clearItemSubscribers(e),this.isComputedItem(e)&&this.#e.delete(e),this.isAtomItem(e)&&this.#s.delete(e),this.isCollection(e)&&this.#r.delete(e),this.#n({[e]:s},"delete")}#c(){return Object.fromEntries(this.#s)}getItems(e=!1){return e?Object.assign({},this.#c(),this.#m()):this.#c()}#d(e){return this.#e.get(e).stale&&this.#h(e),this.#e.get(e).value}#y(e){return this.#r.get(e)}#m(){let e={};return this.#e.forEach(t=>{e[t.item_name]=this.#d(t.item_name)}),e}#w(e){return this.#s.get(e)}getItem(e){if(e=="store")return this;if(!this.hasItem(e))return null;if(this.isAtomItem(e))return this.#w(e);if(this.isComputedItem(e))return this.#d(e);if(this.isCollection(e))return this.#y(e)}getItemNames(){return[].concat(Array.from(this.#s.keys()),Array.from(this.#e.keys()),Array.from(this.#r.keys()))}subscribe(e,t){return this.#t.on(e,t)}hasSubscribers(e){let t=this.#t.events[e];return t?t.length>0:!1}clearSubscribers(){this.#t.events={}}clearItemSubscribers(e){delete this.#t.events[e]}reset(){this.#s.clear(),this.#e.clear(),this.#r.clear(),this.clearSubscribers()}#n(e,t=null){let s={details:e,eventType:t};this.#t.emit("change",s,this)}asObject(){return this.#o||(this.#o=this.#C()),this.#o}#C(){let e={},t=this,s={get(n,i){return typeof i=="string"?t.getItem(i):null},set(n,i,r){return t.setItems({[i]:r}),!0},ownKeys(n){return t.getItemNames()},getOwnPropertyDescriptor(n){return{enumerable:!0,configurable:!0}},deleteProperty:function(n,i){return typeof i=="string"&&t.deleteItem(i),!0}};return new Proxy(e,s)}setCompareFunction(e,t){return this.hasItem(e)?(this.#i[e]=t,!0):!1}isSealed(){return this.#l}seal(){this.#l=!0}unseal(){this.#l=!1}};function C(o){return new g(o)}export{c as EventEmitter,g as Store,a as UpdateEventDetails,C as createStore};
